<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=0, initial-scale=1.0"
    />
    <title>Hello WebXR!</title>

    <link rel="stylesheet" href="style.css" />

    <!-- three.js -->

    <script src="./modules/landmarks.js"></script>
    <script src="./modules/camera_utils.js"></script>
    <script src="./modules/hands.js"></script>
    <script src="./modules/draw_style.js"></script>
    <script src="./modules/drawing_utils.js"></script>
    <script src="./modules/faust_params.js"></script>
    <script src="./modules/misc_utils.js"></script>
    <script src="./faust_index.js"></script>

    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <!-- Add these imports after the three.js script -->
    <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/shaders/CopyShader.js"></script>

    <script src="./modules/threejs/three.js"></script>
    <!-- Add these imports after the three.js script -->
    <script src="./modules/threejs/EffectComposer.js"></script>
    <script src="./modules/threejs/RenderPass.js"></script>
    <script src="./modules/threejs/ShaderPass.js"></script>
    <script src="./modules/threejs/CopyShader.js"></script>

    <script src="./modules/shaders/vertex.js"></script>
    <script src="./modules/shaders/fragment.js"></script>

    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"
    ></script>

    <!-- Add before your module script -->
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
    ></script>

    <script type="module">
      // all taken from https://cdn.jsdelivr.net/npm/@mediapipe/hands

      // needs to find:
      // http://localhost:8080/modules/hand_landmark_full.tflite
      // http://localhost:8080/modules/hands_solution_packed_assets_loader.js
      // http://localhost:8080/modules/hands_solution_simd_wasm_bin.js
      // http://localhost:8080/modules/hands.binarypb

      // https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands_solution_packed_assets.data

      import {
        FilesetResolver,
        FaceDetector,
      } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

      let scene, camera, renderer;
      const videoElement = document.createElement("video");
      videoElement.classList.add("video-feed");
      document.body.appendChild(videoElement);

      const SHADERS_ENABLED = true;

      // Add these lines to create video texture and plane
      const videoTexture = new THREE.VideoTexture(videoElement);
      let aspectRatio = window.innerWidth / window.innerHeight;
      let composer;

      const scaler = {
        x: 1 * aspectRatio * 1.1,
        y: 1,
        z: 1,
      };

      const pointScaler = {
        x: scaler.x * 2.75,
        y: scaler.y * 2.75,
        z: scaler.z * 2.75,
      };

      let minZValue = Infinity;
      let maxZValue = -Infinity;

      const findZRange = (zValue) => {
        minZValue = Math.min(minZValue, zValue);
        maxZValue = Math.max(maxZValue, zValue);
        console.log(minZValue, maxZValue);
      };

      let leftEyePoints = Array(15).fill(new THREE.Vector3(0, 0, 0));
      let rightEyePoints = Array(15).fill(new THREE.Vector3(0, 0, 0));

      let facePoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)];

      let textureA = new THREE.WebGLRenderTarget(
        window.innerWidth,
        window.innerHeight,
        { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter }
      );

      let textureB = new THREE.WebGLRenderTarget(
        window.innerWidth,
        window.innerHeight,
        { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter }
      );

      let LensDistortionShader = {
        uniforms: {
          tDiffuse: { value: textureA.texture },
          tVideo: { value: videoTexture },
          tPrevious: { value: null },
          distortion: { value: 0.3 },
          distortion2: { value: 0.8 },
          scale: { value: 0.8 },
          leftEyePoints: { value: leftEyePoints },
          rightEyePoints: { value: rightEyePoints },
          time: { value: 0.0 },
          resolution: {
            value: new THREE.Vector2(window.innerWidth, window.innerHeight),
          },
          nosePosition: { value: new THREE.Vector3(0, 0, 0) },
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
      };

      const planeGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
      const planeMaterial = new THREE.MeshBasicMaterial({
        // NOTE: uncomment to use video texture for debugging
        // map: videoTexture,
        side: THREE.DoubleSide,
      });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      // Position the plane behind other elements
      plane.position.z = 8;

      plane.scale.set(scaler.x, scaler.y, scaler.z);
      // Scale the plane to fill the view
      // plane.scale.set(1.5, 1.5, 1.5);
      plane.renderOrder = -1;

      // Initialize Three.js scene
      const container = document.getElementById("container");
      const threeScene = createScene(container);
      scene = threeScene.scene;
      camera = threeScene.camera;
      renderer = threeScene.renderer;

      renderer.autoClear = false;

      renderer.getContext().enableVertexAttribArray(1);

      // Add the plane to the scene
      scene.add(plane);

      const attachFaustNode = async () => {
        await faustNode.then((faustNode) => {
          console.log("faustNode", faustNode.setParamValue);
          window.faustNode = faustNode;
          faustNode.setParamValue("/hand_synth/gate", 1.0);
          console.log("faustNode attached");
        });
      };

      // Add after renderer initialization

      // Replace or modify the createScene function
      function createScene(container) {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Add post-processing setup
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        if (SHADERS_ENABLED) {
          const distortionPass = new THREE.ShaderPass(LensDistortionShader);
          distortionPass.renderToScreen = true;
          composer.addPass(distortionPass);
        }

        return { scene, camera, renderer };
      }

      // Add this near the top of your module script, before any function definitions
      const startTime = Date.now();

      // Modify the animate function where it updates the time uniform
      function animate() {
        requestAnimationFrame(animate);

        if (SHADERS_ENABLED) {
          if (
            window.lastFaceLandmarks !== undefined &&
            window.lastFaceLandmarks.length > 0
          ) {
            const time = (Date.now() - startTime) * 0.001; // Convert to seconds
            composer.passes[1].uniforms.time.value = time;

            const distortionValue = 0.0;

            // Update shader uniforms
            composer.passes[1].uniforms.distortion.value = distortionValue;
            composer.passes[1].uniforms.distortion2.value = distortionValue;
            composer.passes[1].uniforms.rightEyePoints.value =
              window.lastRightEyeLandmarks;
            composer.passes[1].uniforms.leftEyePoints.value =
              window.lastLeftEyeLandmarks;

            if (window.lastNoseLandmark !== null) {
              composer.passes[1].uniforms.nosePosition.value =
                window.lastNoseLandmark;

              // console.log(composer.passes[1].uniforms.nosePosition.value.z);
            }

            composer.passes[1].uniforms.tVideo.value = videoTexture;

            // Render to textureB
            renderer.setRenderTarget(textureB);
            renderer.render(scene, camera);

            // Swap textures for feedback
            var t = textureA;
            textureA = textureB;
            textureB = t;

            // Update the plane material with the new texture
            planeMaterial.map = textureB.texture;
            composer.passes[1].uniforms.tPrevious.value = textureA.texture;

            // Render final output
            renderer.setRenderTarget(null);
            composer.render();
          } else {
            const time = (Date.now() - startTime) * 0.001; // Convert to seconds
            const distortionValue = 0.3 + Math.sin(time) * 0.2;
            composer.passes[1].uniforms.distortion.value = distortionValue;
            composer.render();
          }
        } else {
          renderer.render(scene, camera);
        }
      }

      animate();

      const debugDiv = document.createElement("div");
      debugDiv.id = "debug-text";
      document.body.appendChild(debugDiv);

      const showDebugText = (results) => {
        let debugText = "";
        if (results.multiHandLandmarks.length === 0) {
          debugText = "No hands detected";
          updateFaustParamsNoLandmarks(window.faustNode);
        } else {
          debugText = results.multiHandLandmarks
            .map((landmarks, index) => formatLandmarks(landmarks, index))
            .join("\n\n");
        }
        debugDiv.textContent = debugText;
      };

      function formatLandmarks(landmarks, handIndex) {
        const landmarkNames = [
          "wrist",
          "thumb_cmc",
          "thumb_mcp",
          "thumb_ip",
          "thumb_tip",
          "index_mcp",
          "index_pip",
          "index_dip",
          "index_tip",
          "middle_mcp",
          "middle_pip",
          "middle_dip",
          "middle_tip",
          "ring_mcp",
          "ring_pip",
          "ring_dip",
          "ring_tip",
          "pinky_mcp",
          "pinky_pip",
          "pinky_dip",
          "pinky_tip",
        ];

        let display = landmarks
          .map((landmark, i) => {
            return (
              `Hand ${handIndex + 1} - ${landmarkNames[i]}:` +
              `  x: ${landmark.x.toFixed(3)}` +
              `  y: ${landmark.y.toFixed(3)}` +
              `  z: ${landmark.z.toFixed(8)}`
            );
          })
          .join("\n");

        return display;
      }

      function onResults(results) {
        // Modify the scene clearing to preserve the video plane
        const objectsToRemove = scene.children.filter(
          (child) => child !== plane
        );

        objectsToRemove.forEach((object) => scene.remove(object));

        if (results.multiHandLandmarks) {
          updateFaustParamsForLandmarks(window.faustNode);
          showDebugText(results);
          let i = 0;
          for (const landmarks of results.multiHandLandmarks) {
            // Transform landmarks to match plane coordinates
            const transformedLandmarks = landmarks.map((landmark) => ({
              x: (landmark.x - 0.5) * pointScaler.x + 0.5,
              y: (landmark.y - 0.5) * pointScaler.y + 0.5,
              z: landmark.z * pointScaler.z || 0,
            }));

            window.lastHandLandmarks = transformedLandmarks;

            drawConnectors(scene, transformedLandmarks, HAND_CONNECTIONS, {
              color: 0x00ff00,
              lineWidth: 2,
            });

            drawLandmarks(scene, transformedLandmarks, {
              color: 0xffffff,
              radius: 4,
              // scaler: pointScaler * poin,
            });

            updateFaustParams(window.faustNode, landmarks); // Keep original landmarks for Faust params
            ++i;
          }
        }
      }

      const hands = new Hands({
        locateFile: (file) => `./modules/hands_files/${file}`,
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults(onResults);

      // Add this import after the existing mediapipe import

      // console.log("AHHHHHHHHHHHHHHHHH", FilesetResolver);

      // Add these declarations near the top of your module script
      // import { FaceMesh } from "@mediapipe/face_mesh";
      // import { FilesetResolver, FaceDetector } from "@mediapipe/tasks-vision";

      // Remove the incorrect face detector initialization and replace with:
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      const faceDetector = await FaceDetector.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite`,
          delegate: "GPU",
          model: "short",
        },
        runningMode: "VIDEO",
      });

      const faceMesh = new FaceMesh({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        },
      });

      // Add face mesh results handler
      faceMesh.onResults((results) => {
        if (results.multiFaceLandmarks) {
          updateFaustParamsForLandmarks(window.faustNode);
          for (const landmarks of results.multiFaceLandmarks) {
            // You can add face mesh visualization here similar to hand landmarks

            const transformedLandmarks = landmarks.map((landmark) => ({
              x: (landmark.x - 0.5) * pointScaler.x + 0.5,
              y: (landmark.y - 0.5) * pointScaler.y + 0.5,
              z: landmark.z * pointScaler.z || 0,
            }));

            window.lastFaceLandmarks = transformedLandmarks;
            let rightEyePoints = [];

            for (let i = 0; i < EYE_POINTS.RIGHT_EYE.length; i++) {
              let x = landmarks[EYE_POINTS.RIGHT_EYE[i]].x,
                y = landmarks[EYE_POINTS.RIGHT_EYE[i]].y;
              rightEyePoints[i] = new THREE.Vector3(
                (x - 0.5) * 0.8 + 0.5,
                (1 - y - 0.5) * 0.7 + 0.5,
                landmarks[EYE_POINTS.RIGHT_EYE[i]].z * pointScaler.z || 0
              );
            }

            for (let i = 0; i < EYE_POINTS.LEFT_EYE.length; i++) {
              let x = landmarks[EYE_POINTS.LEFT_EYE[i]].x,
                y = landmarks[EYE_POINTS.LEFT_EYE[i]].y;
              leftEyePoints[i] = new THREE.Vector3(
                (x - 0.5) * 0.8 + 0.5,
                (1 - y - 0.5) * 0.7 + 0.5,
                landmarks[EYE_POINTS.LEFT_EYE[i]].z * pointScaler.z || 0
              );
            }

            const noseLandmark = landmarks[FACE_LANDMARKS.NOSE]; // Replace NOSE_INDEX with the correct index for the nose
            const transformedNose = new THREE.Vector3(
              (noseLandmark.x - 0.5) * pointScaler.x + 0.5,
              (noseLandmark.y - 0.5) * pointScaler.y + 0.5,
              noseLandmark.z * pointScaler.z || 0
            );
            window.lastNoseLandmark = transformedNose;
            // console.log("NOSE", transformedNose.z);

            const referencePoints = [
              new THREE.Vector3(0.25, 0.25, 0),
              new THREE.Vector3(0.25, 0.5, 0),
              new THREE.Vector3(0.25, 0.75, 0),

              new THREE.Vector3(0.5, 0.25, 0),
              new THREE.Vector3(0.5, 0.5, 0),
              new THREE.Vector3(0.5, 0.75, 0),

              new THREE.Vector3(0.75, 0.25, 0),
              new THREE.Vector3(0.75, 0.5, 0),
              new THREE.Vector3(0.75, 0.75, 0),
            ];

            for (let i = 0; i < referencePoints.length; i++) {
              referencePoints[i].x =
                (referencePoints[i].x - 0.5) * aspectRatio * 3.8 + 0.5;
              referencePoints[i].y = (referencePoints[i].y - 0.5) * 3.8 + 0.5;
              referencePoints[i].z = 0;
            }

            drawLandmarks(scene, referencePoints, {
              color: 0x00ff00,
              radius: 4,
            });

            drawLandmarks(scene, [leftEyePoints, rightEyePoints], {
              color: 0x00ff00,
              radius: 4,
            });

            window.lastRightEyeLandmarks = rightEyePoints;
            window.lastLeftEyeLandmarks = leftEyePoints;

            drawLandmarks(scene, transformedLandmarks, {
              color: 0x0000ff,
              lineWidth: 1,
              radius: 1,
            });

            // console.log(landmarks);

            updateFaustParams(window.faustNode, landmarks); // Keep original landmarks for Faust params
          }
        } else {
          updateFaustParamsNoLandmarks(window.faustNode);
        }
      });

      // Modify your camera setup to process both hands and face
      const canvasCamera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
          await faceMesh.send({ image: videoElement });
        },
        width: window.innerWidth,
        height: window.innerHeight,
        facingMode: "environment",
      });

      canvasCamera.start();
      console.log(canvasCamera);

      // aspectRatio = canvasCamera.h.width / canvasCamera.h.height;

      await attachFaustNode();

      // Add after composer initialization
      const prevFrameTarget = new THREE.WebGLRenderTarget(
        window.innerWidth * window.devicePixelRatio,
        window.innerHeight * window.devicePixelRatio
      );
    </script>
  </head>

  <body>
    <div id="container"></div>
  </body>
</html>
